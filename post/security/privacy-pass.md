---
calendar: security
post_year: 2020
post_day: 5
title: From Coils to Curves
image: ""
ingress: Elliptic curves are seemingly ubiquitous in modern cryptographic
  protocols, and may turn up again later this December. Let’s take this
  opportunity to gain some insight on what they are and why they are used.
links: []
authors:
  - Tjerand Silde
  - Martin Strand
---
<!--StartFragment-->

It is well known that prime numbers are important for cryptography, although it has not always been true. The advent of primes came with several ground-breaking papers almost 50 years ago. Pioneers in introducing asymmetric cryptography, Whit Diffie, Martin Hellman, Ron Rivest, Adi Shamir and Leonard Adleman used results from number theory to build key agreement, encryption, and signatures. Prime numbers hold a very special position in number theory, and this carried over to cryptography.

## From Primes to Crypto

Our cryptographic protocols are working \_modulo\_ some prime \_p\_. This can be likened to turning the number line into a coil, such that 0, \_p\_, 2\_p\_, etc. all join at the same place. From then on, whenever we add or multiply the number such that we go beyond \_p\_, we can simply remove as many multiples of \_p\_ as necessary until we come between 0 and \_p\_ again.

Now, imagine that we used a composite number instead, for example 12. Then 0 and 12 are “the same” in this situation, but that also means that 3 multiplied by 4 is ... 0! One of the intuitions when working with the normal numbers is that if \_ab\_ = 0, then either \_a\_ or \_b\_ would have to be 0. Hence, when using composite numbers, there is simply stuff that no longer works the way we’re used to. Fortunately, this is not the case when using the primes as our so-called modulus.

Let’s make a rule, and let’s call it \_m\_. We take the coil we just made from the number line, and since we can always reduce numbers to below \_p\_, we label our points on this circle from 0 to \_p\_-1. Given two points \_a\_ and \_b\_ on the circle, we decided that the output of the rule \_m\_(\_a\_, \_b\_) should be the point which is represented by the product \_ab\_, possibly after reducing modulo \_p\_. It may look like a very natural rule, but it is nonetheless a rule we just agreed on. If you play around with this rule a bit, you will notice some properties:

* If \_a\_ = 1, then \_m\_(\_a\_, \_b\_) = \_b\_ (and the other way around).
* For any \_a\_, \_b\_ not equal to 0, \_m\_(\_a\_, \_b\_) is never zero. So, if we removed 0 from the circle entirely, no harm would happen -- the rule would still be well-defined.
* For any \_a\_, there is always some \_b\_ such that \_m\_(\_a\_, \_b\_) = 1.



These nice properties -- together with a property called associativity -- are the properties we need to be able to do cryptographic computations.

Now focus on a particular number on the circle, and let’s call it \_g\_. If we take \_m\_(\_g\_, \_g\_), or -- to return to the more usual notation -- \_g\_<sup>2</sup>, we will reach a new point on the circle. We can continue this process and compute \_g\_<sup>3</sup>, \_g\_<sup>4</sup>, etc. At some point, we will reach 1. All the points we have visited in this process are members of the set of numbers _generated by \_g\_, and if the number of points on the coil is a large prime, then we have a very good candidate for doing cryptography, for example Diffie-Hellman key exchange. Let \_h\_ be some number in this set generated by \_g\_. That means that \_h\_ = \_g\_<sup>e</sup> for some exponent \_e\_. If it is easy to find this \_e\_ from \_g\_ and \_h\_, we would have trouble. Fortunately, it turns out that if we just use \*large enough\* primes, then this \_e\_ appears to be very difficult to find.



![](https://lh5.googleusercontent.com/Hzr0-Km7K5zX4APfHFJdsCrjrPkiJzklm2uu2LqM_65QAuwJPbG0izxWvKu7iHBIC-4HLnF2kYHkl8-dXLyRIOxw17SaMwCVbnpkhIHutMEZZe40E_uJ-SmG69RKWhCxlg)

## From Coils to Curves

Coiling up the number line is not the only way of finding suitable primitives for cryptography. Let’s make a new rule. Instead of using a circle like we did in the previous section, we consider the equation



\_y\_<sup>2</sup> = \_x\_<sup>3</sup> + \_ax\_ + \_b\_.



If we graph this in our usual coordinate system, it will look like this red curve:

![](https://lh3.googleusercontent.com/pT2oDZYUzpVpjFxK-eXwnwCUb8u8midCmcTglc-UZOdTXvrPW1Dr1uxj0NdJgAlrwd36XRSQ6gtrP4ppEQpUcztUysmOu3snUnp26ihBPKz6VK9zB6c5CRxSDCZTGnmy1Q)



We will now make a rule on how to combine the points \_P\_ and \_Q\_ on this curve. The agreed upon notation is to call this rule addition, but we will have to define what we mean by that. Programming languages often include this mental concept as operation overloading. Draw the straight line between \_P\_ and \_Q\_. It will intersect at a third point, say, \_R\_. This could have been a nice candidate for \_P\_ + \_Q\_, but since we are making the rules, let’s make this a bit more interesting. Draw a vertical line through \_R\_. It will intersect the curve on the opposite side of the \_x\_-axis, and we define this point as \_P\_ + \_Q\_. Just as before, this is a rule we’re deciding here and now. However, this also turns out to be a very useful rule, with the same properties:



* Instead of having the point 1 on the circle, we imagine a point at infinity. (Remember what you see when looking at railway tracks: Parallel lines actually meet beyond the horizon, at infinity.) So, now the line intersecting \_R\_ and \_P\_ + \_Q\_ is indeed also intersecting a third point: the point at infinity. This can be made precise, but requires maths from algebraic geometry, which is far beyond the scope of this blog post. This point at infinity has all the same properties as 1 had above.
* For any point \_S\_ on the curve, there is always a point \_T\_ such that we get a line intersecting \_S\_, \_T\_ and the point at infinity. Indeed, in the previous example this was \_Q\_. This means that for any point \_S\_, we can find a point we can call -\_S\_.



INSERT GIF

In particular, take a point \_G\_, and compute 2\_G\_ = \_G\_ + \_G\_, 3\_G\_, 4\_G\_, etc. Eventually, we reach the point at infinity, and then back to \_G\_. We have now spent about 1000 words getting here, just to do the same as we did above, and what was the point? Above, we said that the computing exponents if the primes were large enough. It turns out that “large enough” is currently about 3072 bits, or a number with approximately 925 digits. That is certainly strenuous for a computer, but the elliptic curve only requires us to work on numbers of size 256 bits, which is far more efficient.

## Elliptic Curve Diffie-Hellman Key-Exchange



![](https://lh5.googleusercontent.com/6gfnHTxvtlNAOsBFmR3qQJK8QIiSWnssefhpW04J_JUEpZVhwc_gBDKh9IR6fkehJAXy8yfewo7I5uSZJNHVcqrOmakoJflIdaGCk-n6f3ojYynagqNNBnOawb1fm49P6Q)



## Common Curves

## Not all elliptic curves are suitable for cryptography. There could also be power in choosing a curve and the distinguished base point(s). Hence, implementations tend to choose among a small number of well-known curves. The US National Institute of Standards and Technology maintains a list of recommended curves; P-256 is perhaps the most popular among these. 

## Among others, there is also the \[SafeCurves](https://safecurves.cr.yp.to) collection proposed by Dan Bernstein and Tanja Lange. In particular, their Curve25519 has proven to be a popular choice.

Elliptic curve libraries will typically have tailored support for certain curves.

## References

* <https://gfycat.com/immaterialcompetentcanine>
* [Elliptic Curves challenges on cryptohack.org](https://cryptohack.org/challenges/ecc/)
* <https://www.ias.edu/ideas/2012/taylor-modular-arithmetic>
* <https://hackernoon.com/what-is-the-math-behind-elliptic-curve-cryptography-f61b25253da3> 
* <https://twitter.com/davidtavarez/status/1109613825484095488> 
* https://csrc.nist.gov/publications/detail/fips/186/4/final

<!--EndFragment-->