---
calendar: security
post_year: 2019
post_day: 16
title: WebAuthn
ingress: >-
  With FIDO2 available the internet has all the tools available to lighten the
  load of the password. Here are the basics to get started with a wide range of
  authenticators.
authors:
  - Mats Jonassen
---
The FIDO Alliance has since 2013 worked towards simpler online authentication and a weaker reliance on passwords. A strong alternative to password authentication is becomming generally available: the cryptographic authenticator. To strengthen the adaption of authenticators W3C released their Web Authentication(WebAuthn) API at their "Recommended" level this March.
WebAuthn moves the burden of authenticator interaction to the users web browser. The API reduces both authenticator selection and communication to the two JS methods create() and get(). Create() is used to register new authenticators, and get() to authenticate users. Both methods accept their own option objects to provide some level of control to implementers, where one can configure options such as desired public-key system.

#### Registering a new authenticator:
To register a new authenticator WebAuthn exposes create(). Create() is called with info such as: identifiers for the relying party, the desired user entity, and options public-key system. The final most important required parameter is the challenge. It is a value generated by the relying party that has to be signed by the authenticator, and validated by the relying party.
Upon registering a new authenticator, the authenticator will generate a new asymmetric-key pair for use in future authentications with get(). The public component will be released in the result of create()

#### Authenticating a user
When it comes to authenticating a user the process becomes even simpler. The relying party information is handled by the browser and the only required parameter is the challenge, again created by the relying party.
The authenticator will look up the private key used to register for the relying party and produce a signature for the relying-party id and challenge.
To verify the authenticator the server must get the public key for the user, and check that the returned data is as expected with a valid signature.

#### Trusting Authenticators
In what we've explained so far, there is no verification that the communcation has infact occured with an authenticator and there is no verification that the authenticator plays by the rules. It is completely possible for a web browser to fake the result of WebAuthn using its own unsecured techniques. To improve authenticator trust WebAuthn specifies rules for attestation. Authenticator attestation utilizes techniques such as X.509 certiciates to build trust paths. If desired in by the options attestation is included in the WebAuthn results, enabling the relying party to conclude wether it wants to trust the authentcation or not.


//TODO

* Image.
* Simplify, simplify, simplify. 
* Remove specs other than crypto primitives and information flow.
* consider code examples
* outro / conclusion

Closing statements?
Browser coverage(https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API)
Outro
